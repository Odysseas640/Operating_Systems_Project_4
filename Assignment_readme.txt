Odysseas Stefas, 1700151

My program starts by setting a global time variable, which is compared to every directory's modified time, to avoid an infinite loop if the destination is inside the origin directory. That is, I don't copy directories that were created by the current execution of the program. Then I get all the arguments, and if the last directory in the destination path doesn't exist, I create it. Then I call the recursive function that copies files.

The recursive function that copies files looks at every entity in the origin directory it is given. If it's a file, it looks for the same file in the destination with stat(), and if it's there and has the same size and date, we move on without copying. When it copies a file, it does it byte-by-byte, for as many bytes as the file is big. I did it like that because I was having problems with copying a PDF file in Greek, it probably saw a character as EOF.
Without the -l flag, hard links are copied as if they were regular files. 
With the -l flag, when a file with 2 or more hard links is found, if it's the first time we've found this inode, the file is copied and the inode number and path are saved in a list. Each hard link to the same inode will have a different path, but it's fine, I only need one of the paths to create a hard link in the destination later. When I find a file with 2 or more hard links, and its inode number is already in the list, then I check if there's already a hard link in the destination, and if not, I create a link to the path in the list. If there's a file with the same name in the destination, but it's not a hard link, it's replaced with a hard link.
When the recursive copy function finds a folder in the origin directory, it looks for the same folder in the destination directory with stat(). If it's not there, it creates it. And then (if the folder was not created just now - to avoid an infinite loop) it calls itself recursively in that folder, with the folder name appended to the origin_dir and dest_dir arguments.

After the recursive function finishes, I call another recursive function that copies soft links specifically. I need a separate recursive function that is called after everything else is copied, because if I try to create a soft link to a file that hasn't been copied yet, it won't work.
This function looks at every entity in the origin directory. If it's a folder, it acts the same as the copy function above.
If it's a soft link, it checks whether the target is inside the origin directory. If it is, the origin directory in the link target path is replaced with the origin directory. Then a soft link is created for the file in the destination directory. If the link target is outside the origin directory, the link in the destination has the same target as in the origin. If there's already a soft link in the destination and it points to the desired file, we move on.

After the soft links function, there is a recursive delete function. It reads every entity in the destination folder. If it's a folder that exists in the origin as well, it calls itself recursively like the first copy function. If the folder doesn't exist in the origin, it is deleted.
If it's anything else, a file or a hard/soft link, it looks for the same file in the origin directory. If it's not there, it's deleted in the destination.
